{% extends "base.html" %}
{% block title %}Channels - Discord Pals{% endblock %}

{% block content %}
<div class="page-header">
    <h1 class="page-title">Channels</h1>
    <p class="page-subtitle">Manage channel settings and autonomous responses</p>
</div>

<!-- Filter Controls -->
<div class="card filter-card">
    <div class="filter-row">
        <div class="filter-group">
            <label for="guild-filter">Server</label>
            <select id="guild-filter" onchange="filterChannels()" title="Filter by server">
                <option value="">All Servers</option>
                {% for guild in guilds %}
                <option value="{{ guild.id }}">{{ guild.name }}</option>
                {% endfor %}
            </select>
        </div>
        <div class="filter-group">
            <label for="auto-filter">Autonomous</label>
            <select id="auto-filter" onchange="filterChannels()" title="Filter by autonomous status">
                <option value="">All</option>
                <option value="enabled">Enabled</option>
                <option value="disabled">Disabled</option>
            </select>
        </div>
        <div class="filter-group">
            <label for="history-filter">History</label>
            <select id="history-filter" onchange="filterChannels()" title="Filter by history">
                <option value="">All</option>
                <option value="yes">With History</option>
                <option value="no">No History</option>
            </select>
        </div>
        <div class="filter-count">
            <span id="channel-count">{{ channels|length }} channels</span>
        </div>
    </div>
</div>

<!-- Channels Table -->
<div class="card">
    <div class="card-header">
        <span class="card-title">Channel List</span>
    </div>

    {% if channels %}
    <div class="table-responsive">
        <table id="channels-table">
            <thead>
                <tr>
                    <th class="sortable" data-sort="channel" onclick="sortTable('channel')">Channel <span class="sort-icon"></span></th>
                    <th class="sortable" data-sort="server" onclick="sortTable('server')">Server <span class="sort-icon"></span></th>
                    <th class="sortable" data-sort="history" onclick="sortTable('history')">History <span class="sort-icon"></span></th>
                    <th class="sortable" data-sort="autonomous" onclick="sortTable('autonomous')">Autonomous <span class="sort-icon"></span></th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody>
                {% for channel in channels %}
                <tr data-channel-id="{{ channel.id }}"
                    data-guild-id="{{ channel.guild_id }}"
                    data-autonomous="{{ 'enabled' if channel.autonomous else 'disabled' }}"
                    data-has-history="{{ 'yes' if channel.history_count > 0 else 'no' }}"
                    data-channel-name="{{ channel.name|lower }}"
                    data-server-name="{{ channel.guild_name|lower }}"
                    data-history-count="{{ channel.history_count }}">
                    <td>
                        <div class="channel-info">
                            <span class="channel-name">#{{ channel.name }}</span>
                            <span class="channel-id">{{ channel.id }}</span>
                        </div>
                    </td>
                    <td>{{ channel.guild_name }}</td>
                    <td>
                        <span class="history-count {% if channel.history_count > 0 %}has-history{% endif %}">
                            {{ channel.history_count }} messages
                        </span>
                    </td>
                    <td>
                        <div class="auto-status" id="auto-status-{{ channel.id }}">
                            {% if channel.autonomous %}
                            <button type="button" class="badge badge-success auto-toggle" onclick="quickToggleAuto('{{ channel.id }}', false)" title="Click to disable">ON</button>
                            <span class="auto-details">{{ channel.auto_chance }}% / {{ channel.auto_cooldown }}min</span>
                            <button type="button" class="badge badge-sm bot-trigger-toggle {% if channel.allow_bot_triggers %}badge-info{% else %}badge-muted{% endif %}" onclick="quickToggleBotTriggers('{{ channel.id }}', {{ 'false' if channel.allow_bot_triggers else 'true' }})" title="{% if channel.allow_bot_triggers %}Bot triggers enabled - click to disable{% else %}Bot triggers disabled - click to enable{% endif %}">
                                bots: {% if channel.allow_bot_triggers %}✓{% else %}✗{% endif %}
                            </button>
                            {% else %}
                            <button type="button" class="badge badge-muted auto-toggle" onclick="quickToggleAuto('{{ channel.id }}', true)" title="Click to enable">OFF</button>
                            {% endif %}
                        </div>
                    </td>
                    <td>
                        <div class="action-buttons">
                            <button type="button" class="btn btn-ghost btn-sm" onclick="openAutoModal('{{ channel.id }}', '{{ channel.name }}', {{ 'true' if channel.autonomous else 'false' }}, {{ channel.auto_chance }}, {{ channel.auto_cooldown }}, {{ 'true' if channel.allow_bot_triggers else 'false' }})">
                                Configure
                            </button>
                            <button type="button" class="btn btn-danger btn-sm" onclick="clearHistory('{{ channel.id }}', '{{ channel.name }}')" {% if channel.history_count == 0 %}disabled{% endif %}>
                                Clear
                            </button>
                        </div>
                    </td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>
    {% else %}
    <div class="card-body">
        <div class="empty">No channels found. Make sure your bots are online and connected to servers.</div>
    </div>
    {% endif %}
</div>

<!-- Autonomous Configuration Modal -->
<div id="auto-modal" class="modal" style="display: none;">
    <div class="modal-content">
        <div class="modal-header">
            <h3 class="modal-title">Configure Channel</h3>
            <p id="auto-modal-channel" class="modal-subtitle"></p>
        </div>

        <!-- Autonomous Mode Section -->
        <div class="config-section">
            <div class="config-section-header">Autonomous Mode</div>
            <div class="form-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="auto-enabled">
                    <span>Enable Autonomous Responses</span>
                </label>
                <p class="form-hint">Bot will occasionally respond without being mentioned</p>
            </div>

            <div id="auto-settings">
                <div class="form-group">
                    <label for="auto-chance">Response Chance: <span id="chance-val">5</span>%</label>
                    <input type="range" id="auto-chance" min="1" max="50" value="5"
                           oninput="document.getElementById('chance-val').textContent = this.value" title="Response chance percentage">
                </div>

                <div class="form-group">
                    <label for="auto-cooldown">Cooldown: <span id="cooldown-val">2</span> minutes</label>
                    <input type="range" id="auto-cooldown" min="1" max="10" value="2"
                           oninput="document.getElementById('cooldown-val').textContent = this.value" title="Cooldown in minutes">
                </div>
            </div>
        </div>

        <!-- Name Trigger Section -->
        <div class="config-section">
            <div class="config-section-header">Name Triggers</div>
            <p class="form-hint" style="margin-bottom: 16px;">Bot responds when its name/nickname is mentioned (requires autonomous mode)</p>

            <div class="form-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="auto-allow-bots">
                    <span>Allow Bot/App Triggers</span>
                </label>
                <p class="form-hint">Other Discord bots can trigger name-based responses</p>
            </div>

            <div class="form-group" id="nickname-settings">
                <label>Bot Nicknames</label>
                <p class="form-hint">Comma-separated list of additional names the bot responds to</p>
                <div id="bot-nicknames-container">
                    <!-- Populated by JavaScript -->
                </div>
            </div>
        </div>

        <div class="modal-buttons">
            <button type="button" class="btn btn-ghost" onclick="closeAutoModal()">Cancel</button>
            <button type="button" class="btn btn-primary" onclick="saveAutoConfig()">Save Changes</button>
        </div>

        <input type="hidden" id="auto-channel-id">
    </div>
</div>

<style>
/* Page Header */
.page-header {
    margin-bottom: 32px;
}

.page-title {
    font-size: 1.875rem;
    font-weight: 600;
    letter-spacing: -0.025em;
    margin-bottom: 4px;
}

.page-subtitle {
    color: var(--text-muted);
    font-size: 0.875rem;
}

/* Filter Card */
.filter-card {
    margin-bottom: 24px;
}

.filter-card .card-body {
    padding: 0;
}

.filter-row {
    display: flex;
    align-items: flex-end;
    gap: 20px;
    flex-wrap: wrap;
    padding: 20px;
}

.filter-group {
    display: flex;
    flex-direction: column;
    gap: 6px;
}

.filter-group label {
    color: var(--text-muted);
    font-size: 0.75rem;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.05em;
}

.filter-group select {
    padding: 8px 12px;
    background: var(--bg-primary);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text-primary);
    font-family: inherit;
    font-size: 0.875rem;
    min-width: 150px;
}

.filter-group select:focus {
    outline: none;
    border-color: var(--accent);
}

.filter-count {
    margin-left: auto;
    color: var(--text-muted);
    font-size: 0.875rem;
}

/* Sortable Headers */
.sortable {
    cursor: pointer;
    -webkit-user-select: none;
    user-select: none;
}

.sortable:hover {
    background: var(--bg-tertiary);
}

.sort-icon {
    margin-left: 4px;
    font-size: 0.75rem;
    opacity: 0.5;
}

.sort-icon::after {
    content: '⇅';
}

.sortable.asc .sort-icon::after {
    content: '↑';
    opacity: 1;
}

.sortable.desc .sort-icon::after {
    content: '↓';
    opacity: 1;
}

/* Channel Info */
.channel-info {
    display: flex;
    flex-direction: column;
    gap: 2px;
}

.channel-name {
    font-weight: 500;
}

.channel-id {
    color: var(--text-muted);
    font-size: 0.75rem;
    font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
}

/* History Count */
.history-count {
    color: var(--text-muted);
    font-size: 0.875rem;
}

.history-count.has-history {
    color: var(--accent);
    font-weight: 500;
}

/* Auto Status */
.auto-status {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
}

.auto-details {
    color: var(--text-muted);
    font-size: 0.75rem;
}

/* Auto Toggle Badge */
.auto-toggle {
    cursor: pointer;
    transition: all 0.15s ease;
    border: none;
    font-weight: 600;
    font-size: 0.6875rem;
}

.auto-toggle:hover {
    transform: scale(1.05);
}

/* Bot Trigger Toggle */
.bot-trigger-toggle {
    cursor: pointer;
    font-size: 0.6875rem;
    padding: 2px 6px;
    border: none;
    transition: all 0.15s ease;
}

.bot-trigger-toggle:hover {
    transform: scale(1.05);
}

.badge-info {
    background: var(--accent);
    color: white;
}

.badge-muted {
    background: var(--bg-tertiary);
    color: var(--text-muted);
}

.badge-muted:hover {
    background: rgba(34, 197, 94, 0.2);
    color: var(--success);
}

.badge-success.auto-toggle:hover {
    background: rgba(239, 68, 68, 0.2);
    color: var(--danger);
}

/* Action Buttons */
.action-buttons {
    display: flex;
    gap: 8px;
}

.btn-sm {
    padding: 6px 12px;
    font-size: 0.8125rem;
}

/* Modal Styles */
.modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.6);
    -webkit-backdrop-filter: blur(4px);
    backdrop-filter: blur(4px);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2000;
}

.modal-content {
    background: var(--bg-secondary);
    border: 1px solid var(--border-subtle);
    border-radius: 12px;
    padding: 24px;
    max-width: 480px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
}

.modal-header {
    margin-bottom: 24px;
}

.modal-title {
    font-size: 1.125rem;
    font-weight: 600;
    margin-bottom: 4px;
}

.modal-subtitle {
    color: var(--accent);
    font-size: 0.875rem;
    font-weight: 500;
}

.modal-buttons {
    display: flex;
    gap: 12px;
    justify-content: flex-end;
    margin-top: 24px;
    padding-top: 20px;
    border-top: 1px solid var(--border-subtle);
}

/* Config Sections */
.config-section {
    margin-bottom: 24px;
    padding-bottom: 24px;
    border-bottom: 1px solid var(--border-subtle);
}

.config-section:last-of-type {
    border-bottom: none;
    margin-bottom: 0;
    padding-bottom: 0;
}

.config-section-header {
    font-weight: 600;
    font-size: 0.875rem;
    margin-bottom: 16px;
    color: var(--text-primary);
}

/* Form Elements */
.form-group {
    margin-bottom: 16px;
}

.form-group:last-child {
    margin-bottom: 0;
}

.form-group label {
    display: block;
    margin-bottom: 6px;
    color: var(--text-secondary);
    font-size: 0.8125rem;
    font-weight: 500;
}

.form-hint {
    color: var(--text-muted);
    font-size: 0.75rem;
    margin-top: 4px;
}

.checkbox-label {
    display: flex;
    align-items: center;
    gap: 10px;
    cursor: pointer;
}

.checkbox-label input[type="checkbox"] {
    width: 16px;
    height: 16px;
    accent-color: var(--accent);
}

.checkbox-label span {
    font-weight: 500;
    color: var(--text-primary);
}

/* Range Input */
input[type="range"] {
    width: 100%;
    height: 6px;
    background: var(--bg-tertiary);
    border-radius: 3px;
    outline: none;
    -webkit-appearance: none;
    margin-top: 8px;
}

input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 16px;
    height: 16px;
    background: var(--accent);
    border-radius: 50%;
    cursor: pointer;
}

input[type="range"]::-moz-range-thumb {
    width: 16px;
    height: 16px;
    background: var(--accent);
    border-radius: 50%;
    cursor: pointer;
    border: none;
}

/* Nickname Rows */
.nickname-row {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-top: 12px;
    padding: 12px;
    background: var(--bg-primary);
    border-radius: 8px;
    border: 1px solid var(--border-subtle);
}

.nickname-row .bot-name {
    min-width: 100px;
    font-weight: 500;
    color: var(--accent);
    font-size: 0.875rem;
}

.nickname-row input {
    flex: 1;
    padding: 8px 12px;
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text-primary);
    font-family: inherit;
    font-size: 0.875rem;
}

.nickname-row input:focus {
    outline: none;
    border-color: var(--accent);
}

.nickname-row input::placeholder {
    color: var(--text-muted);
}

/* Hidden rows */
tr.hidden {
    display: none;
}

/* Disabled state for auto settings */
#auto-settings.disabled {
    opacity: 0.5;
    pointer-events: none;
}

/* Responsive */
@media (max-width: 768px) {
    .filter-row {
        flex-direction: column;
        align-items: stretch;
    }

    .filter-group {
        width: 100%;
    }

    .filter-group select {
        width: 100%;
    }

    .filter-count {
        margin-left: 0;
        margin-top: 8px;
    }

    .action-buttons {
        flex-direction: column;
    }

    .nickname-row {
        flex-direction: column;
        align-items: stretch;
    }

    .nickname-row .bot-name {
        min-width: auto;
    }
}
</style>

<script>
let currentChannelId = null;
let botNicknames = {};
let currentSort = { column: null, direction: 'asc' };

// Load bot nicknames on page load
async function loadBotNicknames() {
    try {
        const response = await fetch('/api/nicknames');
        const data = await response.json();
        botNicknames = data.nicknames || {};
    } catch (e) {
        console.error('Failed to load bot nicknames:', e);
    }
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', loadBotNicknames);

// Sort table
function sortTable(column) {
    const table = document.getElementById('channels-table');
    const tbody = table.querySelector('tbody');
    const rows = Array.from(tbody.querySelectorAll('tr'));

    // Toggle direction if same column
    if (currentSort.column === column) {
        currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
    } else {
        currentSort.column = column;
        currentSort.direction = 'asc';
    }

    // Update header classes
    document.querySelectorAll('.sortable').forEach(th => {
        th.classList.remove('asc', 'desc');
    });
    const activeHeader = document.querySelector(`.sortable[data-sort="${column}"]`);
    if (activeHeader) {
        activeHeader.classList.add(currentSort.direction);
    }

    // Sort rows
    rows.sort((a, b) => {
        let aVal, bVal;

        switch (column) {
            case 'channel':
                aVal = a.dataset.channelName || '';
                bVal = b.dataset.channelName || '';
                break;
            case 'server':
                aVal = a.dataset.serverName || '';
                bVal = b.dataset.serverName || '';
                break;
            case 'history':
                aVal = parseInt(a.dataset.historyCount) || 0;
                bVal = parseInt(b.dataset.historyCount) || 0;
                break;
            case 'autonomous':
                aVal = a.dataset.autonomous === 'enabled' ? 1 : 0;
                bVal = b.dataset.autonomous === 'enabled' ? 1 : 0;
                break;
            default:
                return 0;
        }

        let result;
        if (typeof aVal === 'number') {
            result = aVal - bVal;
        } else {
            result = aVal.localeCompare(bVal);
        }

        return currentSort.direction === 'asc' ? result : -result;
    });

    // Re-append sorted rows
    rows.forEach(row => tbody.appendChild(row));
}

// Filter channels
function filterChannels() {
    const guildFilter = document.getElementById('guild-filter').value;
    const autoFilter = document.getElementById('auto-filter').value;
    const historyFilter = document.getElementById('history-filter').value;

    const rows = document.querySelectorAll('#channels-table tbody tr');
    let visibleCount = 0;

    rows.forEach(row => {
        let show = true;

        if (guildFilter && row.dataset.guildId !== guildFilter) {
            show = false;
        }

        if (autoFilter && row.dataset.autonomous !== autoFilter) {
            show = false;
        }

        if (historyFilter && row.dataset.hasHistory !== historyFilter) {
            show = false;
        }

        row.classList.toggle('hidden', !show);
        if (show) visibleCount++;
    });

    document.getElementById('channel-count').textContent = `${visibleCount} channels`;
}

// Open autonomous configuration modal
function openAutoModal(channelId, channelName, enabled, chance, cooldown, allowBots) {
    currentChannelId = channelId;
    document.getElementById('auto-modal-channel').textContent = `#${channelName}`;
    document.getElementById('auto-channel-id').value = channelId;
    document.getElementById('auto-enabled').checked = enabled;
    document.getElementById('auto-chance').value = chance;
    document.getElementById('chance-val').textContent = chance;
    document.getElementById('auto-cooldown').value = cooldown;
    document.getElementById('cooldown-val').textContent = cooldown;
    document.getElementById('auto-allow-bots').checked = allowBots || false;

    // Populate nickname inputs for each bot
    const container = document.getElementById('bot-nicknames-container');
    container.innerHTML = '';

    for (const [botName, nicknames] of Object.entries(botNicknames)) {
        const row = document.createElement('div');
        row.className = 'nickname-row';
        const span = document.createElement('span');
        span.className = 'bot-name';
        span.textContent = botName;
        const input = document.createElement('input');
        input.type = 'text';
        input.id = 'nickname-' + botName.replace(/\s+/g, '-');
        input.dataset.botName = botName;
        input.value = nicknames || '';
        input.placeholder = 'e.g., bestie, buddy';
        input.title = 'Nicknames for ' + botName;
        row.appendChild(span);
        row.appendChild(input);
        container.appendChild(row);
    }

    // If no bots loaded yet, show a message
    if (Object.keys(botNicknames).length === 0) {
        container.innerHTML = '<p class="form-hint">Loading bot info...</p>';
        loadBotNicknames().then(() => {
            if (Object.keys(botNicknames).length > 0) {
                openAutoModal(channelId, channelName, enabled, chance, cooldown, allowBots);
            }
        });
    }

    document.getElementById('auto-modal').style.display = 'flex';
    toggleAutoSettings();
}

function closeAutoModal() {
    document.getElementById('auto-modal').style.display = 'none';
    currentChannelId = null;
}

function toggleAutoSettings() {
    const enabled = document.getElementById('auto-enabled').checked;
    const settings = document.getElementById('auto-settings');
    if (enabled) {
        settings.classList.remove('disabled');
    } else {
        settings.classList.add('disabled');
    }
}

document.getElementById('auto-enabled').addEventListener('change', toggleAutoSettings);

// Save autonomous configuration and nicknames
async function saveAutoConfig() {
    const saveBtn = document.querySelector('#auto-modal .btn-primary');
    if (saveBtn) {
        saveBtn.disabled = true;
        saveBtn.textContent = 'Saving...';
    }

    const channelId = document.getElementById('auto-channel-id').value;
    const enabled = document.getElementById('auto-enabled').checked;
    const chance = parseInt(document.getElementById('auto-chance').value);
    const cooldown = parseInt(document.getElementById('auto-cooldown').value);
    const allowBotTriggers = document.getElementById('auto-allow-bots').checked;

    let hasErrors = false;

    try {
        // Save nicknames for each bot
        const nicknameInputs = document.querySelectorAll('#bot-nicknames-container input[data-bot-name]');
        for (const input of nicknameInputs) {
            const botName = input.dataset.botName;
            const nicknames = input.value.trim();

            if (botNicknames[botName] !== nicknames) {
                try {
                    const response = await fetch('/api/nicknames', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRF-Token': '{{ csrf_token() }}'
                        },
                        body: JSON.stringify({ bot_name: botName, nicknames: nicknames })
                    });

                    const data = await response.json();
                    if (data.status === 'ok') {
                        botNicknames[botName] = nicknames;
                    } else {
                        hasErrors = true;
                    }
                } catch (e) {
                    hasErrors = true;
                }
            }
        }

        // Save autonomous settings
        const response = await fetch(`/api/channels/${channelId}/autonomous`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': '{{ csrf_token() }}'
            },
            body: JSON.stringify({ enabled, chance, cooldown, allow_bot_triggers: allowBotTriggers })
        });

        const data = await response.json();

        if (data.status === 'ok') {
            const row = document.querySelector(`tr[data-channel-id="${channelId}"]`);
            if (row) {
                row.dataset.autonomous = enabled ? 'enabled' : 'disabled';
                const statusDiv = document.getElementById(`auto-status-${channelId}`);
                const botIcon = allowBotTriggers ? ' +bots' : '';
                if (enabled) {
                    statusDiv.innerHTML = `
                        <button type="button" class="badge badge-success auto-toggle" onclick="quickToggleAuto('${channelId}', false)" title="Click to disable">ON</button>
                        <span class="auto-details">${chance}% / ${cooldown}min${botIcon}</span>
                    `;
                } else {
                    statusDiv.innerHTML = `<button type="button" class="badge badge-muted auto-toggle" onclick="quickToggleAuto('${channelId}', true)" title="Click to enable">OFF</button>`;
                }
            }

            if (hasErrors) {
                showToast('Settings saved (some nickname updates failed)', 'warning');
            } else {
                showToast('Settings saved successfully', 'success');
            }
            closeAutoModal();
        } else {
            showToast('Failed to save configuration', 'error');
        }
    } catch (e) {
        showToast('Error saving configuration', 'error');
    } finally {
        if (saveBtn) {
            saveBtn.disabled = false;
            saveBtn.textContent = 'Save Changes';
        }
    }
}

// Clear channel history
function clearHistory(channelId, channelName) {
    showConfirm(
        'Clear History',
        `Are you sure you want to clear all conversation history for #${channelName}? This cannot be undone.`,
        async () => {
            try {
                const response = await fetch(`/api/channels/${channelId}/clear`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': '{{ csrf_token() }}'
                    }
                });

                const data = await response.json();

                if (data.status === 'ok') {
                    const row = document.querySelector(`tr[data-channel-id="${channelId}"]`);
                    if (row) {
                        row.dataset.hasHistory = 'no';
                        const countSpan = row.querySelector('.history-count');
                        countSpan.textContent = '0 messages';
                        countSpan.classList.remove('has-history');

                        const clearBtn = row.querySelector('.btn-danger');
                        if (clearBtn) clearBtn.disabled = true;
                    }

                    showToast(`History cleared for #${channelName}`, 'success');
                } else {
                    showToast('Failed to clear history', 'error');
                }
            } catch (e) {
                showToast('Error clearing history', 'error');
            }
        }
    );
}

// Close modal on outside click
document.getElementById('auto-modal').addEventListener('click', function(e) {
    if (e.target === this) {
        closeAutoModal();
    }
});

// Quick toggle autonomous mode
async function quickToggleAuto(channelId, enable) {
    try {
        const getResponse = await fetch(`/api/channels/${channelId}/autonomous`);
        if (!getResponse.ok) {
            showToast('Failed to get current settings', 'error');
            return;
        }
        const currentSettings = await getResponse.json();

        const chance = currentSettings.chance || 5;
        const cooldown = currentSettings.cooldown || 2;
        const allowBotTriggers = currentSettings.allow_bot_triggers || false;

        const response = await fetch(`/api/channels/${channelId}/autonomous`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': '{{ csrf_token() }}'
            },
            body: JSON.stringify({ enabled: enable, chance, cooldown, allow_bot_triggers: allowBotTriggers })
        });

        const data = await response.json();

        if (data.status === 'ok') {
            const row = document.querySelector(`tr[data-channel-id="${channelId}"]`);
            if (row) {
                row.dataset.autonomous = enable ? 'enabled' : 'disabled';
                const statusDiv = document.getElementById(`auto-status-${channelId}`);
                const botTriggersEnabled = data.allow_bot_triggers;
                if (enable) {
                    statusDiv.innerHTML = `
                        <button type="button" class="badge badge-success auto-toggle" onclick="quickToggleAuto('${channelId}', false)" title="Click to disable">ON</button>
                        <span class="auto-details">${data.chance}% / ${data.cooldown}min</span>
                        <button type="button" class="badge badge-sm bot-trigger-toggle ${botTriggersEnabled ? 'badge-info' : 'badge-muted'}" onclick="quickToggleBotTriggers('${channelId}', ${!botTriggersEnabled})" title="${botTriggersEnabled ? 'Bot triggers enabled - click to disable' : 'Bot triggers disabled - click to enable'}">
                            bots: ${botTriggersEnabled ? '✓' : '✗'}
                        </button>
                    `;
                } else {
                    statusDiv.innerHTML = `<button type="button" class="badge badge-muted auto-toggle" onclick="quickToggleAuto('${channelId}', true)" title="Click to enable">OFF</button>`;
                }
            }

            showToast(enable ? 'Autonomous mode enabled' : 'Autonomous mode disabled', 'success');
        } else {
            showToast('Failed to toggle autonomous mode', 'error');
        }
    } catch (e) {
        showToast('Error toggling autonomous mode', 'error');
    }
}

// Quick toggle bot triggers
async function quickToggleBotTriggers(channelId, enable) {
    try {
        const getResponse = await fetch(`/api/channels/${channelId}/autonomous`);
        if (!getResponse.ok) {
            showToast('Failed to get current settings', 'error');
            return;
        }
        const currentSettings = await getResponse.json();

        const response = await fetch(`/api/channels/${channelId}/autonomous`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': '{{ csrf_token() }}'
            },
            body: JSON.stringify({
                enabled: currentSettings.enabled,
                chance: currentSettings.chance,
                cooldown: currentSettings.cooldown,
                allow_bot_triggers: enable
            })
        });

        const data = await response.json();

        if (data.status === 'ok') {
            const statusDiv = document.getElementById(`auto-status-${channelId}`);
            const botToggle = statusDiv.querySelector('.bot-trigger-toggle');
            if (botToggle) {
                botToggle.className = `badge badge-sm bot-trigger-toggle ${enable ? 'badge-info' : 'badge-muted'}`;
                botToggle.setAttribute('onclick', `quickToggleBotTriggers('${channelId}', ${!enable})`);
                botToggle.setAttribute('title', enable ? 'Bot triggers enabled - click to disable' : 'Bot triggers disabled - click to enable');
                botToggle.textContent = `bots: ${enable ? '✓' : '✗'}`;
            }

            showToast(enable ? 'Bot triggers enabled' : 'Bot triggers disabled', 'success');
        } else {
            showToast('Failed to toggle bot triggers', 'error');
        }
    } catch (e) {
        showToast('Error toggling bot triggers', 'error');
    }
}
</script>
{% endblock %}
