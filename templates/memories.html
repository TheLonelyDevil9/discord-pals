{% extends "base.html" %}
{% block title %}Memories - Discord Pals{% endblock %}

{% block content %}
<div class="page-header">
    <h1 class="page-title">Memories</h1>
    <p class="page-subtitle">Manage bot memories and server lore</p>
</div>

<!-- Tab Navigation -->
<div class="tabs">
    <button type="button" class="tab active" onclick="switchTab('files')">Memory Files</button>
    <button type="button" class="tab" onclick="switchTab('add')">Add Memory</button>
    <button type="button" class="tab" onclick="switchTab('lore')">Server Lore</button>
</div>

<!-- Memory Files Tab -->
<div id="tab-files" class="tab-content active">
    <!-- Statistics Overview -->
    <div class="stats-row">
        <div class="stat-card">
            <span class="stat-value" id="total-memories">0</span>
            <span class="stat-label">Total Memories</span>
        </div>
        <div class="stat-card">
            <span class="stat-value" id="auto-memories">0</span>
            <span class="stat-label">Auto-Generated</span>
        </div>
        <div class="stat-card">
            <span class="stat-value" id="manual-memories">0</span>
            <span class="stat-label">Manual</span>
        </div>
    </div>

    <!-- Filter Controls -->
    <div class="filter-row">
        <div class="form-group">
            <label for="type-filter">Type</label>
            <select id="type-filter" onchange="filterMemories()" title="Filter by memory type">
                <option value="">All Types</option>
                <option value="memories">Server</option>
                <option value="user_profiles">Global Profiles</option>
                <option value="dm_memories">DM</option>
                <option value="user_memories">User</option>
                <option value="lore">Lore</option>
            </select>
        </div>
        <div class="form-group">
            <label for="auto-filter">Source</label>
            <select id="auto-filter" onchange="filterMemories()" title="Filter by source">
                <option value="">All</option>
                <option value="auto">Auto</option>
                <option value="manual">Manual</option>
            </select>
        </div>
        <div class="form-group flex-1">
            <label for="memory-search">Search</label>
            <input type="text" id="memory-search" placeholder="Search memories..." oninput="filterMemories()" title="Search memory content">
        </div>
        <div class="form-group">
            <label for="sort-by">Sort</label>
            <select id="sort-by" onchange="sortMemories()" title="Sort memories">
                <option value="newest">Newest First</option>
                <option value="oldest">Oldest First</option>
            </select>
        </div>
    </div>

    {% if memories %}
    {% for file_name, data in memories.items() %}
    <div class="card memory-file-card memory-section" data-file="{{ file_name }}">
        <div class="card-header clickable" onclick="toggleMemoryCard('{{ file_name }}')">
            <span class="card-title">
                <span class="collapse-icon">▼</span>
                {{ file_name }} <span class="badge badge-muted memory-count">0</span>
            </span>
            <div>
                <button type="button" class="btn btn-ghost btn-sm" onclick="event.stopPropagation(); openAddMemoryModal('{{ file_name }}')">Add</button>
                <a href="/memories/{{ file_name }}/edit" class="btn btn-ghost btn-sm" onclick="event.stopPropagation()">Raw JSON</a>
            </div>
        </div>

        <div class="card-body collapsible" id="section-{{ file_name }}">
            <div class="memory-list" id="list-{{ file_name }}">
                <div class="memory-loading">Loading memories...</div>
            </div>
        </div>
    </div>
    {% endfor %}
    {% else %}
    <div class="card">
        <div class="empty">No memory files found in <code>bot_data/</code></div>
    </div>
    {% endif %}
</div>

<!-- Add Memory Tab -->
<div id="tab-add" class="tab-content">
    <div class="card">
        <div class="card-header">
            <span class="card-title">Add New Memory</span>
        </div>
        <div class="card-body">
            <p class="tab-description">Manually add memories that the bot will remember about servers or users.</p>

            <div class="form-row">
                <div class="form-group">
                    <label for="memory-type">Memory Type</label>
                    <select id="memory-type" onchange="updateMemoryForm()" title="Select memory type">
                        <option value="server">Server Memory (shared)</option>
                        <option value="lore">Server Lore (world-building)</option>
                        <option value="global">Global User Profile (cross-server)</option>
                    </select>
                </div>
                <div class="form-group" id="guild-select-group">
                    <label for="memory-guild">Server</label>
                    <select id="memory-guild" title="Select a server">
                        <option value="">Select a server...</option>
                        {% for guild in guilds %}
                        <option value="{{ guild.id }}">{{ guild.name }}</option>
                        {% endfor %}
                    </select>
                </div>
            </div>

            <div class="form-row hidden" id="user-id-row">
                <div class="form-group">
                    <label for="memory-user-id">User ID</label>
                    <input type="text" id="memory-user-id" placeholder="Discord User ID">
                </div>
            </div>

            <div class="form-group">
                <label for="memory-content">Memory Content</label>
                <textarea id="memory-content" placeholder="Enter the memory content..." title="Memory content"></textarea>
            </div>

            <button type="button" class="btn btn-primary" onclick="addMemory()">Save Memory</button>
        </div>
    </div>
</div>

<!-- Lore Tab -->
<div id="tab-lore" class="tab-content">
    <div class="card">
        <div class="card-header">
            <span class="card-title">Server Lore Management</span>
        </div>
        <div class="card-body">
            <p class="tab-description">Lore is world-building information that helps the bot understand the context of your server.</p>

            {% if guilds %}
            <div class="form-group">
                <label for="lore-guild">Select Server</label>
                <select id="lore-guild" onchange="loadLore()" title="Select a server">
                    <option value="">Select a server...</option>
                    {% for guild in guilds %}
                    <option value="{{ guild.id }}" data-lore="{{ guild.lore | e }}">{{ guild.name }}</option>
                    {% endfor %}
                </select>
            </div>

            <div id="lore-editor" class="hidden">
                <div class="form-group">
                    <label for="lore-content">Current Lore</label>
                    <textarea id="lore-content" placeholder="No lore set for this server..." title="Server lore content"></textarea>
                </div>

                <div class="lore-actions">
                    <button type="button" class="btn btn-primary" onclick="saveLore(false)">Append Lore</button>
                    <button type="button" class="btn btn-ghost" onclick="saveLore(true)">Replace Lore</button>
                    <button type="button" class="btn btn-danger" onclick="clearLore()">Clear Lore</button>
                </div>
            </div>
            {% else %}
            <div class="empty">No servers available. Make sure your bots are online.</div>
            {% endif %}
        </div>
    </div>
</div>

<!-- Memory Edit/Add Modal -->
<div id="memory-modal" class="modal" style="display: none;">
    <div class="modal-content">
        <div class="modal-header">
            <h3 id="modal-title">Edit Memory</h3>
            <button type="button" class="btn btn-ghost btn-sm" onclick="closeModal()" style="margin-left: auto;">&times;</button>
        </div>
        <div class="form-group">
            <label for="modal-content-input">Content</label>
            <textarea id="modal-content-input" rows="4" placeholder="Enter memory content..."></textarea>
        </div>
        <div style="display: flex; gap: 16px;">
            <div class="form-group" style="flex: 1;">
                <label for="modal-character">Character</label>
                <select id="modal-character">
                    <option value="">None</option>
                    {% if characters %}
                    {% for char in characters %}
                    <option value="{{ char }}">{{ char }}</option>
                    {% endfor %}
                    {% endif %}
                </select>
            </div>
            <div class="form-group" style="flex: 1;">
                <label for="modal-auto">Type</label>
                <select id="modal-auto">
                    <option value="false">Manual</option>
                    <option value="true">Auto</option>
                </select>
            </div>
        </div>
        <div class="modal-buttons" style="display: flex; gap: 12px; justify-content: flex-end; margin-top: 20px;">
            <button type="button" class="btn btn-ghost" onclick="closeModal()">Cancel</button>
            <button type="button" class="btn btn-primary" onclick="saveMemory()">Save</button>
        </div>
        <input type="hidden" id="modal-file">
        <input type="hidden" id="modal-key">
        <input type="hidden" id="modal-index">
        <input type="hidden" id="modal-parent-key">
        <input type="hidden" id="modal-mode" value="edit">
    </div>
</div>

<style>
/* Page Header */
.page-header {
    margin-bottom: 32px;
}

.page-title {
    font-size: 1.875rem;
    font-weight: 600;
    letter-spacing: -0.025em;
    margin-bottom: 4px;
}

.page-subtitle {
    color: var(--text-muted);
    font-size: 0.875rem;
}

.tab-description {
    color: var(--text-muted);
    font-size: 0.875rem;
    margin-bottom: 20px;
}

/* Memory File Card */
.memory-file-card {
    margin-bottom: 20px;
}

/* Collapsible Card Header */
.card-header.clickable {
    cursor: pointer;
    -webkit-user-select: none;
    user-select: none;
}

.card-header.clickable:hover {
    background: var(--bg-tertiary);
}

.collapse-icon {
    margin-right: 8px;
    font-family: monospace;
    font-size: 0.75rem;
    transition: transform 0.2s ease;
}

/* Collapsed state */
.collapsible.collapsed {
    display: none;
}

/* Memories Table */
.memories-table {
    table-layout: fixed;
}

.memories-table .col-checkbox {
    width: 48px;
}

.memories-table .col-key {
    width: 180px;
}

.memories-table .col-action {
    width: 100px;
}

.memories-table td {
    vertical-align: top;
}

.user-name-hint {
    color: var(--accent);
    font-size: 0.75rem;
    margin-top: 4px;
}

.memory-text {
    color: var(--text-secondary);
    font-size: 0.8125rem;
}

.memory-content {
    max-height: 150px;
    overflow: auto;
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 0.75rem;
    background: var(--bg-primary);
    padding: 8px;
    border-radius: 6px;
    border: 1px solid var(--border-subtle);
    margin: 0;
}

/* Bulk Actions */
.bulk-actions {
    display: flex;
    gap: 12px;
    border-top: 1px solid var(--border-subtle);
}

/* Form Layout */
.form-row {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 16px;
    margin-bottom: 16px;
}

.form-group textarea {
    min-height: 120px;
}

/* Lore Actions */
.lore-actions {
    display: flex;
    gap: 12px;
    margin-top: 16px;
}

/* Utility */
.hidden {
    display: none !important;
}

/* Responsive */
@media (max-width: 768px) {
    .form-row {
        grid-template-columns: 1fr;
    }

    .bulk-actions {
        flex-direction: column;
    }

    .lore-actions {
        flex-direction: column;
    }

    .memories-table .col-key {
        width: 120px;
    }
}

/* Memory Card UI */
.memory-card {
    background: var(--bg-primary);
    border: 1px solid var(--border-subtle);
    border-radius: 8px;
    padding: 16px;
    margin-bottom: 12px;
}
.memory-card:hover { border-color: var(--border); }

.memory-card-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 12px;
}
.memory-card-meta { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
.memory-card-content { font-size: 0.875rem; line-height: 1.6; margin-bottom: 12px; white-space: pre-wrap; word-wrap: break-word; }
.memory-card-footer { font-size: 0.75rem; color: var(--text-muted); }
.memory-card-actions { display: flex; gap: 8px; }

/* Badges */
.badge-auto { background: var(--accent-muted, rgba(99, 102, 241, 0.15)); color: var(--accent, #6366f1); }
.badge-manual { background: var(--success-muted, rgba(34, 197, 94, 0.15)); color: var(--success, #22c55e); }
.badge-muted { background: var(--bg-tertiary); color: var(--text-muted); }

/* Stats Row */
.stats-row {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 16px;
    margin-bottom: 24px;
}
.stat-card {
    background: var(--bg-secondary);
    border: 1px solid var(--border-subtle);
    border-radius: 12px;
    padding: 20px;
    text-align: center;
}
.stat-value { font-size: 2rem; font-weight: 600; display: block; }
.stat-label { font-size: 0.75rem; color: var(--text-muted); text-transform: uppercase; }

/* Filter Controls */
.filter-row {
    display: flex;
    gap: 16px;
    flex-wrap: wrap;
    margin-bottom: 20px;
    padding: 16px;
    background: var(--bg-secondary);
    border: 1px solid var(--border-subtle);
    border-radius: 8px;
}
.filter-row .form-group {
    margin: 0;
}
.filter-row .form-group.flex-1 {
    flex: 1;
    min-width: 200px;
}

/* Memory List Container */
.memory-list {
    display: flex;
    flex-direction: column;
}
.memory-list-empty {
    color: var(--text-muted);
    text-align: center;
    padding: 20px;
}

/* Loading state */
.memory-loading {
    text-align: center;
    padding: 40px;
    color: var(--text-muted);
}

@media (max-width: 768px) {
    .filter-row {
        flex-direction: column;
    }
    .memory-card-header {
        flex-direction: column;
        gap: 12px;
    }
    .memory-card-actions {
        width: 100%;
        justify-content: flex-end;
    }
}
</style>

<script>
// Collapsible memory cards
function toggleMemoryCard(fileName) {
    const card = document.querySelector(`.memory-file-card[data-file="${fileName}"]`);
    if (!card) return;

    const collapsibles = card.querySelectorAll('.collapsible');
    const icon = card.querySelector('.collapse-icon');
    const isCollapsed = collapsibles[0]?.classList.contains('collapsed');

    collapsibles.forEach(el => {
        if (isCollapsed) {
            el.classList.remove('collapsed');
        } else {
            el.classList.add('collapsed');
        }
    });

    if (icon) {
        icon.textContent = isCollapsed ? '▼' : '▶';
    }

    // Save state to localStorage
    const collapsedCards = JSON.parse(localStorage.getItem('memoryCardsCollapsed') || '{}');
    collapsedCards[fileName] = !isCollapsed;
    localStorage.setItem('memoryCardsCollapsed', JSON.stringify(collapsedCards));
}

// Initialize collapsed state on page load
function initCollapsedState() {
    const collapsedCards = JSON.parse(localStorage.getItem('memoryCardsCollapsed') || '{}');

    document.querySelectorAll('.memory-file-card').forEach(card => {
        const fileName = card.dataset.file;

        // Use saved state if available
        let shouldCollapse = false;
        if (fileName in collapsedCards) {
            shouldCollapse = collapsedCards[fileName];
        }

        if (shouldCollapse) {
            const collapsibles = card.querySelectorAll('.collapsible');
            const icon = card.querySelector('.collapse-icon');
            collapsibles.forEach(el => el.classList.add('collapsed'));
            if (icon) icon.textContent = '▶';
        }
    });
}

// Run on page load
initCollapsedState();

// Tab switching
function switchTab(tabName) {
    document.querySelectorAll('.tab').forEach(btn => btn.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

    document.querySelector(`[onclick="switchTab('${tabName}')"]`).classList.add('active');
    document.getElementById('tab-' + tabName).classList.add('active');
}

// Update memory form based on type
function updateMemoryForm() {
    const type = document.getElementById('memory-type').value;
    const userIdRow = document.getElementById('user-id-row');
    const guildSelect = document.getElementById('guild-select-group');

    if (type === 'global') {
        userIdRow.classList.remove('hidden');
        guildSelect.classList.add('hidden');
    } else {
        userIdRow.classList.add('hidden');
        guildSelect.classList.remove('hidden');
    }
}

// Add memory
async function addMemory() {
    const type = document.getElementById('memory-type').value;
    const guildId = document.getElementById('memory-guild').value;
    const userId = document.getElementById('memory-user-id').value;
    const content = document.getElementById('memory-content').value.trim();

    if (!content) {
        showToast('Please enter memory content', 'error');
        return;
    }

    if ((type === 'server' || type === 'lore') && !guildId) {
        showToast('Please select a server', 'error');
        return;
    }

    if (type === 'global' && !userId) {
        showToast('Please enter a user ID', 'error');
        return;
    }

    try {
        const response = await fetch('/api/memories/add', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': '{{ csrf_token() }}'
            },
            body: JSON.stringify({
                type: type,
                guild_id: guildId,
                user_id: userId,
                content: content
            })
        });

        const data = await response.json();

        if (data.status === 'ok') {
            showToast('Memory saved successfully!', 'success');
            document.getElementById('memory-content').value = '';
            setTimeout(() => location.reload(), 1000);
        } else {
            showToast(data.message || 'Failed to save memory', 'error');
        }
    } catch (e) {
        showToast('Error saving memory', 'error');
    }
}

// Load lore for selected guild
function loadLore() {
    const select = document.getElementById('lore-guild');
    const editor = document.getElementById('lore-editor');
    const textarea = document.getElementById('lore-content');

    if (!select.value) {
        editor.classList.add('hidden');
        return;
    }

    const option = select.options[select.selectedIndex];
    const lore = option.dataset.lore || '';

    textarea.value = lore;
    editor.classList.remove('hidden');
}

// Save lore
async function saveLore(replace) {
    const guildId = document.getElementById('lore-guild').value;
    const content = document.getElementById('lore-content').value.trim();

    if (!guildId) {
        showToast('Please select a server', 'error');
        return;
    }

    if (!content && !replace) {
        showToast('Please enter lore content', 'error');
        return;
    }

    try {
        const response = await fetch(`/api/lore/${guildId}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': '{{ csrf_token() }}'
            },
            body: JSON.stringify({
                content: content,
                replace: replace
            })
        });

        const data = await response.json();

        if (data.status === 'ok') {
            showToast(replace ? 'Lore replaced!' : 'Lore appended!', 'success');
            const option = document.querySelector(`#lore-guild option[value="${guildId}"]`);
            if (option) {
                option.dataset.lore = replace ? content : (option.dataset.lore || '') + '\n' + content;
            }
        } else {
            showToast('Failed to save lore', 'error');
        }
    } catch (e) {
        showToast('Error saving lore', 'error');
    }
}

// Clear lore
function clearLore() {
    const guildId = document.getElementById('lore-guild').value;

    if (!guildId) {
        showToast('Please select a server', 'error');
        return;
    }

    showConfirm('Clear Lore', 'Are you sure you want to clear all lore for this server?', async () => {
        try {
            const response = await fetch(`/api/lore/${guildId}`, {
                method: 'DELETE',
                headers: { 'X-CSRF-Token': '{{ csrf_token() }}' }
            });

            const data = await response.json();

            if (data.status === 'ok') {
                showToast('Lore cleared!', 'success');
                document.getElementById('lore-content').value = '';
                const option = document.querySelector(`#lore-guild option[value="${guildId}"]`);
                if (option) option.dataset.lore = '';
            } else {
                showToast('Failed to clear lore', 'error');
            }
        } catch (e) {
            showToast('Error clearing lore', 'error');
        }
    });
}

// Delete memory confirmation
function confirmDeleteMemory(fileName, key) {
    showConfirm('Delete Memory', 'Are you sure you want to delete this memory entry?', function() {
        const form = document.createElement('form');
        form.method = 'POST';
        form.action = '/memories/' + fileName + '/delete';
        const csrfInput = document.createElement('input');
        csrfInput.type = 'hidden';
        csrfInput.name = 'csrf_token';
        csrfInput.value = '{{ csrf_token() }}';
        form.appendChild(csrfInput);
        const input = document.createElement('input');
        input.type = 'hidden';
        input.name = 'key';
        input.value = key;
        form.appendChild(input);
        document.body.appendChild(form);
        form.submit();
    });
}

// Toggle select all checkboxes
function toggleSelectAll(fileName) {
    const selectAllCheckbox = document.getElementById(`select-all-${fileName}`);
    const checkboxes = document.querySelectorAll(`.memory-checkbox[data-file="${fileName}"]`);
    checkboxes.forEach(cb => cb.checked = selectAllCheckbox.checked);
}

// Get selected memory keys
function getSelectedMemories(fileName) {
    const checkboxes = document.querySelectorAll(`.memory-checkbox[data-file="${fileName}"]:checked`);
    return Array.from(checkboxes).map(cb => cb.dataset.key);
}

// Delete selected memories
async function deleteSelectedMemories(fileName) {
    const selectedKeys = getSelectedMemories(fileName);

    if (selectedKeys.length === 0) {
        showToast('No memories selected', 'error');
        return;
    }

    showConfirm(
        'Delete Selected Memories',
        `Are you sure you want to delete ${selectedKeys.length} selected memor${selectedKeys.length === 1 ? 'y' : 'ies'}?`,
        async function() {
            try {
                const response = await fetch(`/api/memories/${fileName}/delete-selected`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': '{{ csrf_token() }}'
                    },
                    body: JSON.stringify({ keys: selectedKeys })
                });

                const data = await response.json();

                if (data.status === 'ok') {
                    showToast(`Deleted ${selectedKeys.length} memor${selectedKeys.length === 1 ? 'y' : 'ies'}!`, 'success');
                    setTimeout(() => location.reload(), 1000);
                } else {
                    showToast(data.message || 'Failed to delete memories', 'error');
                }
            } catch (e) {
                showToast('Error deleting memories', 'error');
            }
        }
    );
}

// Clear all memories
function clearAllMemories(fileName) {
    showConfirm(
        'Clear All Memories',
        `This will permanently delete ALL memories in ${fileName}. This action cannot be undone. Are you sure?`,
        async function() {
            try {
                const response = await fetch(`/api/memories/${fileName}/clear-all`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': '{{ csrf_token() }}'
                    }
                });

                const data = await response.json();

                if (data.status === 'ok') {
                    showToast('All memories cleared!', 'success');
                    setTimeout(() => location.reload(), 1000);
                } else {
                    showToast(data.message || 'Failed to clear memories', 'error');
                }
            } catch (e) {
                showToast('Error clearing memories', 'error');
            }
        }
    );
}

// ===== NEW MEMORY CARD UI FUNCTIONS =====

// HTML escaping utility
function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Render memory card HTML
function renderMemoryCard(memory, fileType, key, index) {
    const timestamp = memory.timestamp
        ? new Date(memory.timestamp).toLocaleString()
        : 'Unknown';
    const isAuto = memory.auto === true;
    const character = memory.character || memory.learned_from || '';
    const userName = memory.user_name || '';
    const parentKey = memory.parent_key || '';

    return `
        <div class="memory-card" data-file="${fileType}" data-key="${escapeHtml(key)}" data-index="${index}" data-parent-key="${escapeHtml(parentKey)}">
            <div class="memory-card-header">
                <div class="memory-card-meta">
                    <span class="badge ${isAuto ? 'badge-auto' : 'badge-manual'}">
                        ${isAuto ? 'Auto' : 'Manual'}
                    </span>
                    ${character ? `<span class="badge badge-muted">${escapeHtml(character)}</span>` : ''}
                    ${userName ? `<span style="color: var(--text-muted); font-size: 0.75rem;">from ${escapeHtml(userName)}</span>` : ''}
                </div>
                <div class="memory-card-actions">
                    <button type="button" class="btn btn-ghost btn-sm" onclick="editMemory('${escapeHtml(fileType)}', '${escapeHtml(key)}', ${index}, '${escapeHtml(parentKey)}')">Edit</button>
                    <button type="button" class="btn btn-danger btn-sm" onclick="deleteMemoryItem('${escapeHtml(fileType)}', '${escapeHtml(key)}', ${index}, '${escapeHtml(parentKey)}')">Delete</button>
                </div>
            </div>
            <div class="memory-card-content">${escapeHtml(memory.content)}</div>
            <div class="memory-card-footer">${timestamp}</div>
        </div>
    `;
}

// Load and render all memories on page load
document.addEventListener('DOMContentLoaded', function() {
    // Load memories if we're on the files tab
    if (document.getElementById('tab-files').classList.contains('active')) {
        loadAllMemories();
    }
});

// Load all memory sections
async function loadAllMemories() {
    const sections = document.querySelectorAll('.memory-section');
    for (const section of sections) {
        const fileType = section.dataset.file;
        await loadMemorySection(fileType);
    }
    updateStats();
}

// Load a single memory section
async function loadMemorySection(fileType) {
    const list = document.getElementById(`list-${fileType}`);
    if (!list) return;

    try {
        const response = await fetch(`/api/memories/${fileType}/entries`);
        const data = await response.json();

        if (data.entries && data.entries.length > 0) {
            list.innerHTML = data.entries.map(e =>
                renderMemoryCard(e, fileType, e.key, e.index)
            ).join('');
        } else {
            list.innerHTML = '<p class="memory-list-empty">No memories stored</p>';
        }

        // Update count badge
        const section = document.querySelector(`.memory-section[data-file="${fileType}"]`);
        if (section) {
            const badge = section.querySelector('.memory-count');
            if (badge) {
                badge.textContent = data.entries.length;
            }
        }
    } catch (error) {
        console.error('Error loading memories:', error);
        list.innerHTML = '<p class="memory-list-empty" style="color: var(--danger)">Error loading memories</p>';
    }
}

// Filter memories based on controls
function filterMemories() {
    const typeFilter = document.getElementById('type-filter').value;
    const autoFilter = document.getElementById('auto-filter').value;
    const search = document.getElementById('memory-search').value.toLowerCase();

    // Filter sections by type
    document.querySelectorAll('.memory-section').forEach(section => {
        const fileType = section.dataset.file;
        section.style.display = (!typeFilter || fileType.includes(typeFilter)) ? '' : 'none';
    });

    // Filter cards by auto/manual and search
    document.querySelectorAll('.memory-card').forEach(card => {
        const content = card.querySelector('.memory-card-content').textContent.toLowerCase();
        const isAuto = card.querySelector('.badge-auto') !== null;

        let show = true;
        if (autoFilter === 'auto' && !isAuto) show = false;
        if (autoFilter === 'manual' && isAuto) show = false;
        if (search && !content.includes(search)) show = false;

        card.style.display = show ? '' : 'none';
    });

    updateStats();
}

// Sort memories
function sortMemories() {
    const sortBy = document.getElementById('sort-by').value;
    document.querySelectorAll('.memory-list').forEach(list => {
        const cards = Array.from(list.querySelectorAll('.memory-card'));
        cards.sort((a, b) => {
            const aTime = a.querySelector('.memory-card-footer').textContent;
            const bTime = b.querySelector('.memory-card-footer').textContent;
            if (sortBy === 'newest') {
                return bTime.localeCompare(aTime);
            } else {
                return aTime.localeCompare(bTime);
            }
        });
        cards.forEach(card => list.appendChild(card));
    });
}

// Update statistics
function updateStats() {
    let total = 0, auto = 0, manual = 0;
    document.querySelectorAll('.memory-card:not([style*="display: none"])').forEach(card => {
        total++;
        card.querySelector('.badge-auto') ? auto++ : manual++;
    });
    document.getElementById('total-memories').textContent = total;
    document.getElementById('auto-memories').textContent = auto;
    document.getElementById('manual-memories').textContent = manual;
}

// Open modal for adding new memory
function openAddMemoryModal(fileType) {
    document.getElementById('modal-title').textContent = 'Add Memory';
    document.getElementById('modal-content-input').value = '';
    document.getElementById('modal-character').value = '';
    document.getElementById('modal-auto').value = 'false';
    document.getElementById('modal-file').value = fileType;
    document.getElementById('modal-key').value = '';
    document.getElementById('modal-index').value = '-1';
    document.getElementById('modal-parent-key').value = '';
    document.getElementById('modal-mode').value = 'add';
    document.getElementById('memory-modal').style.display = 'flex';
}

// Edit memory
async function editMemory(fileType, key, index, parentKey = '') {
    try {
        let url = `/api/memories/${fileType}/entry/${key}/${index}`;
        if (parentKey) {
            url += `?parent_key=${encodeURIComponent(parentKey)}`;
        }

        const response = await fetch(url);
        const data = await response.json();

        document.getElementById('modal-title').textContent = 'Edit Memory';
        document.getElementById('modal-content-input').value = data.content || '';
        document.getElementById('modal-character').value = data.character || data.learned_from || '';
        document.getElementById('modal-auto').value = data.auto ? 'true' : 'false';
        document.getElementById('modal-file').value = fileType;
        document.getElementById('modal-key').value = key;
        document.getElementById('modal-index').value = index;
        document.getElementById('modal-parent-key').value = parentKey || '';
        document.getElementById('modal-mode').value = 'edit';
        document.getElementById('memory-modal').style.display = 'flex';
    } catch (error) {
        console.error('Error loading memory:', error);
        showToast('Error loading memory', 'error');
    }
}

// Save memory (edit or add)
async function saveMemory() {
    const mode = document.getElementById('modal-mode').value;
    const fileType = document.getElementById('modal-file').value;
    const key = document.getElementById('modal-key').value;
    const index = parseInt(document.getElementById('modal-index').value);
    const parentKey = document.getElementById('modal-parent-key').value;

    const payload = {
        content: document.getElementById('modal-content-input').value,
        character: document.getElementById('modal-character').value,
        auto: document.getElementById('modal-auto').value === 'true'
    };

    if (!payload.content.trim()) {
        showToast('Please enter memory content', 'error');
        return;
    }

    try {
        if (mode === 'edit') {
            // Update existing memory
            let url = `/api/memories/${fileType}/entry/${key}/${index}`;
            if (parentKey) {
                url += `?parent_key=${encodeURIComponent(parentKey)}`;
            }

            await fetch(url, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': '{{ csrf_token() }}'
                },
                body: JSON.stringify(payload)
            });

            showToast('Memory updated', 'success');
        } else {
            // Add new memory - use existing add API
            showToast('Adding new memories through the modal is not yet implemented. Please use the "Add Memory" tab.', 'info');
            closeModal();
            return;
        }

        closeModal();
        loadMemorySection(fileType);
        updateStats();
    } catch (error) {
        console.error('Error saving memory:', error);
        showToast('Error saving memory', 'error');
    }
}

// Delete memory item
async function deleteMemoryItem(fileType, key, index, parentKey = '') {
    if (!confirm('Delete this memory?')) return;

    try {
        let url = `/api/memories/${fileType}/entry/${key}/${index}`;
        if (parentKey) {
            url += `?parent_key=${encodeURIComponent(parentKey)}`;
        }

        await fetch(url, {
            method: 'DELETE',
            headers: { 'X-CSRF-Token': '{{ csrf_token() }}' }
        });

        showToast('Memory deleted', 'success');
        loadMemorySection(fileType);
        updateStats();
    } catch (error) {
        console.error('Error deleting memory:', error);
        showToast('Error deleting memory', 'error');
    }
}

// Close modal
function closeModal() {
    document.getElementById('memory-modal').style.display = 'none';
}

// Close modal when clicking outside
document.addEventListener('click', function(event) {
    const modal = document.getElementById('memory-modal');
    if (event.target === modal) {
        closeModal();
    }
});
</script>
{% endblock %}
